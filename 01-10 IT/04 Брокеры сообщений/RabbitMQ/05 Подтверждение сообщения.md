Выполнение задачи может занять несколько секунд, вы можете задаться вопросом, что произойдет, если потребитель начнет длинную задачу и завершит ее до завершения. С нашим текущим кодом, как только RabbitMQ доставляет сообщение потребителю, он немедленно помечает его для удаления. В этом случае, если вы завершаете рабочий процесс, сообщение, которое он только что обрабатывал, теряется. Сообщения, которые были отправлены этому конкретному работнику, но еще не были обработаны, также теряются.

Но мы не хотим терять ни одной задачи. Если рабочий умирает, мы хотели бы, чтобы задача была доставлена ​​другому рабочему.

Чтобы гарантировать, что сообщение никогда не потеряется, RabbitMQ поддерживает _подтверждения_ сообщений. Подтверждение (знание) отправляется обратно потребителем, чтобы сообщить RabbitMQ, что конкретное сообщение было получено, обработано и что RabbitMQ может удалить его.

Если потребитель умирает (его канал закрыт, соединение закрыто или соединение TCP потеряно) без отправки подтверждения, RabbitMQ поймет, что сообщение не было полностью обработано, и повторно поставит его в очередь. Если в то же время в сети есть другие потребители, он быстро повторно доставит его другому потребителю. Таким образом, вы можете быть уверены, что ни одно сообщение не будет потеряно, даже если работники иногда умирают.

Тайм-аут (по умолчанию 30 минут) применяется при подтверждении доставки потребителем. Это помогает обнаруживать ошибочных (зависших) потребителей, которые никогда не подтверждают доставку.

Подтверждения сообщений ранее были отключены нами. Пришло время включить их, установив для четвертого параметра basic_consume значение false (true означает _отсутствие подтверждения_) и отправить правильное подтверждение от worker, как только мы закончим задачу.