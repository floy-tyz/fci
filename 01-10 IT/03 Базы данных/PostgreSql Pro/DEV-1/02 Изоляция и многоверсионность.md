https://edu.postgrespro.ru/dev1-12/dev1_03_arch_mvcc_overview.html

### Многоверсионность
Для многоверсионности postgres создает копию одной и той же строки для разных транзакций. Самый простой случай использования данного принципа одновременная транзакция на чтение и запись. Для того чтобы различать версии транзакций используют временный отметки. Таким образом пишущая транзакция работает со своим снимком, а читающая со своим.

### Изоляция
В Postgres используется изоляция на основе снимков данных. При выполнении той или иной транзакции она должна видеть только одну версию строки в таблице. Какую именно версию строки нужно предоставить транзакции зависит от снимка данных, созданный на определенный момент времени. В снимке видны последние зафиксированные данные на момент создания снимка. Сам снимок это пара чисел - номер последней зафиксированной транзакции на момент создания снимка и список активных транзакций, они нужны для того чтобы определить еще незавершенные транзакции.
![[Pasted image 20240106200229.png|center|500]]
Тем самым мы видим, что на изображении последняя версия строки №1, строка №2 вскоре будет удалена, но текущий снимок данных об этом еще не знает, строка №3 уже удалена и зафиксирована, наш снимок данных уже знает об этом.

### Условия изоляции
Стандарт SQL определяет 4 основных уровня изоляции, каждый уровень из которых по разному получает снимки данных. Стандарт определяет 4 условия, которые недопустимы на определенных уровнях изоляции.
1) Грязное чтение - чтение незафиксированных данных
2) Неповторяемое чтение - после чтения одних и тех же данных, транзакция обнаруживает, что данные первого запроса и данные второго запроса в рамках одной транзакции различаются, так как во время выполнения параллельная транзакция изменила данные
3) Фантомное чтение - во время чтения строк, выполняется параллельная транзакция из-за которой данный из первой выборки и из второй будут различаться.
4) Аномалия сериализации - результат выполнения двух параллельных транзакций может быть не согласован при всевозможных вариантах исполнения по-очереди
![[Pasted image 20240112145409.png|center]]

### Уровни изоляции 
Как и говорилось ранее в postgres 4 уровня изоляции, но поддерживается только 3, первый уровень Read Uncommited не поддерживается из-за паттерна MVCC.

##### Read Uncommited
Read Uncommited - читает все данные, даже не зафиксированные транзакцией, все 4 условия изоляции нарушены. Не поддерживается в postgres 
##### Read Commited
Read Commited - данный уровень изоляции выбирается по умолчанию, читает все данные, но только те которые были зафиксированы транзакцией. Неповторяемое чтение | Фантомное чтение | Аномалия сериализации возникают на данном уровне изоляции. В данном уровне изоляции может произойти ситуация, когда в одной транзакции два последовательных SELECT одной и той же таблицы могут вернуть два разных результата, так как снапшот данных берется вначале каждого оператора. Таким образом если параллельная транзакция изменит данные, то во втором SELECT мы увидим изменения.

Рассмотрим ситуацию, когда две параллельные транзакции пытаются обновить одну и ту же строку. 
![[Pasted image 20240112162750.png|center|600]]
В данной транзакции мы изменяем две записи с определенными acctnum, если возникнет параллельная транзакция на изменение acctnum 12345, то ничего не случится, все отработает корректно, так как одна из транзакций будет ждать своей очереди на выполнение запроса. Данные так-же будут свежие, так как они будут получены непосредственно во время выполнение оператора UPDATE, а не в начале операции.

##### Read Repeatable
В режиме Repeatable Read видны только те данные, которые были зафиксированы до начала транзакции, но не видны не зафиксированные данные и изменения, произведённые другими транзакциями в процессе выполнения данной транзакции. Главным отличием данного уровня изоляции от предыдущего является снапшот данных вначале транзакции, а также наличие ошибки сериализации при параллельном изменении. 

Рассмотрим снова пример, когда две параллельные транзакции пытаются обновить одну и ту же строку. 
![[Pasted image 20240112162750.png|center|600]]
В данном случае при существовании другой транзакции на обновление произойдет следующее: Если транзакция на фото будет выполняться первой, то ее изменения будут зафиксированы, а изменения второй параллельной транзакции будут не зафиксированы.

Данный уровень изоляции гарантирует, что каждая транзакция видит стабильное представление данных, но при этом не гарантирует, что представление обязательно будет согласовано с некоторым последовательным выполнением транзакций одного уровня. Чтобы при параллельных транзакциях любые транзакции видели полностью стабильное представление нужно использовать следующий уровень - **Serializable**, который предотвращает аномалии сериализации.

Для реализации уровня изоляции Repeatable Read применяется подход, который называется в академической литературе по базам данных и в других СУБД _Изоляция снимков_

##### Serializable

Данный уровень обеспечивает максимально строгую изоляцию транзакций, выполняя транзакции с данным типом изоляции только последовательно. На данном уровне так-же необходимо иметь защиту от ошибки сериализации или же аномалии сериализации, которая рассматривалась выше. Главным отличием данного типа изоляции (кроме последовательного выполнения) является тот факт, что дополнительно отслеживаются условия, при которых результат параллельно выполняемых сериализуемых транзакций может не согласовываться с результатом этих же транзакций, выполняемых по очереди.

Данная возможность доступна благодаря использования предикатных блокировок, которые физически не блокируют данные, но дают понимать, что данные как-то связаны. Записываются в таблицу pg_locks

### Блокировки

Многоверсионность позволяет обойтись необходимым минимумом блокировок, тем самым увеличивая производительность системы. Основные блокировки устанавливаются на уровне строк.

**При этом чтение никогда не блокирует ни читающие, ни пишущие транзакции**. 
**Изменение строки не блокирует ее чтение.** 

Единственный случай, когда транзакция будет ждать освобождения блокировки — если она пытается менять строку, которая уже изменена другой, еще не зафиксированной, транзакцией. Блокировки также устанавливаются на более высоком уровне,в частности, на таблицах. Они нужны для того, чтобы никто не смог удалить таблицу, пока другие транзакции читают из нее данные, или чтобы запретить доступ к перестраиваемой таблице. Как правило, такие блокировки не вызывают проблем, поскольку удаление или перестроение таблиц — очень редкие операции.


