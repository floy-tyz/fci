https://www.youtube.com/watch?v=ju9F8OvnL4E

1) OLTP - Online Transaction Processing - обработка транзакций в реальном времени. Способ организации БД, при котором система работает с небольшими по размерам транзакциями, но идущими большим потоком, и при этом клиенту требуется от системы минимальное время отклика.
2) bloat - распухание индекса (данные в индексе не очищаются так же как и данные в таблицах с помощью vacum)
3) Что такое плохие запросы - плохие запросы это не только медленные запросы, но еще и быстрые запросы которые приходят в бд очень часто и при этом они не оптимизированы. Решение explain analyze, pg_stat_statments
4) Для построения запроса планировщик выбирает самый оптимизированный вариант выполнения запроса опираясь при этом на таблицу pg_stats
5) Типы индексов: 
	1) b-tree (сбалансированное бинарное дерево) - наиболее распространенный индекс, покрывает 90% задач
	2) hash индекс - в postgres вместо них лучше использовать b-tree
	3) gist индекс - индекс для работы с гео-данными, позволяет решать геометрические задачи, а также есть расширения по-типу pg-trgm - like, ilike, regexp
	4) gin индекс - можно использовать для текстового поиска с расширением pg_trgm, кушает очень много места на диске из-за личного кеш журнала. Так же можно использовать для поиска данных в json
	5) brin -  предназначен для обработки очень больших таблиц, в которых данные упорядочены по какому-то значению. 

6) Индексы автоматически создаются только для primary key, для внешних ключей индекс нужно создавать самостоятельно.
7) Для увеличения производительности можно использовать индекс с дополнительным where is not null, в том случае когда в таблице pg_stats у нас большое количество null значений
8) В OLTP нагрузке всегда должен быть одноядерный последовательный поиск, без параллельных воркеров. Так как в случае использования параллельных воркеров, ядро будет браться из другого соединения, тем самым делая его медленнее. Чтобы все соединения были равны использовать его не нужно.
9) Частичные индексы - в случае если у нас есть запрос на апи в котором мы получаем какие-либо стейты (обработан, не обработан, ошибка выполнения), то есть смысл создать индекс. Просто создавать индекс на стейт не имеет смысла, так как он имеет у нас всего 3 значения и это нам ничего не даст. Одним из хороших вариантов будет использование в индексе дополнительного поля, например created_at. Тем самым мы будет получать условно 100 последних created_at неверно обработанных запросов. Данный вариант хороший, но потребляет большое количество памяти. Чтобы сделать индекс менее увесистым, можно создать индекс только на одно поле created_at и добавить where, где условие будет != обработано, в случае если у нас апи работает конкретно с ошибочными запросами.
10) В случае если нужно сделать аналитику по конкретно "обработано" стейту, то можно во-первых сделать ограничение на выгрузку данных, например по тому же created_at (в течении одного дня), а во-вторых сделать дополнительным полем в индексе какой-то конкретный аргумент, например item = 'яблоко', тем самым получаем составной индекс (created_at, item)
11) Индекс нужно стараться выставлять на колонки с уникальными значениями (наиболее селективные)