tags: [[Структуры данных]] 

Большое О используется для измерения эффективности кода или эффективности использования памяти. 

Скорость выполнения кода зависит от разных факторов:
+ От мощности процессора
+ От работающих на фоне программ
+ От входных данных и их количества
+ От других факторов

Для того чтобы абстрагироваться от данных факторов существует нотация большого О, которая определяет насколько быстро растет время выполнения нашей программы. В нотации большого О под размером входных данных подразумевается «n».

Большое О может иметь два состояния - "Постоянное время выполнения" или "Линейное время выполнения". 

При постоянном времени выполнении, время выполнения никогда не измениться, например получение первого элемента массива - O(1). 

При линейном времени выполнения, время выполнения будет изменяться в зависимости от количества входных данных, например вывод 10 элементов или вывод 1000 элементов массива - O(n). Линейная сложность растет вместе со сложностью алгоритма, например если код имеет двойную вложенность кода, то его O, будет иметь значение O(n * n) или O(n^2). 

Совершенно неважно в каком формате будут поступать данные, будь это значение которое указывает на длину цикла или массив элементов, которые нужно будет проитерировать нотация все равно будет иметь величину O(n), при одинарной вложенности.

Термин большого О отбрасывает константы, поэтому если в методе присутствует два цикла, то логически подумать, что сложность будет O(2n), но мы не учитываем данный фактор, поэтому при таком поведении сложность все равно будет O(n). Именно поэтому не всегда стоит ориентироваться на эту нотацию, так как может возникнуть ситуация, когда алгоритмическая сложность не изменилась, но при этом оптимизация существенно выросла.

Зачастую при линейном выполнении подразумевается наихудшее время выполнения. Если взять задачу на поиск числа в массиве, то он может оказаться как первым O(1), так и последним O(n). Поэтому для алгоритмах так же можно заявлять о времени выполнении в среднем случае.

Вопросы: 
1) Что такое алгоритмическая сложность?
2) Какие типы бывают?

links: 
+ interviewcake.com/article/php/logarithms
+ 